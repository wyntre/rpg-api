package actions

import (
	"database/sql"
	"github.com/dgrijalva/jwt-go"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/nulls"
	"github.com/gobuffalo/pop/v5"
	"github.com/gofrs/uuid"
	"github.com/pkg/errors"
	"github.com/wyntre/rpg_api/models"
	"net/http"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Campaign)
// DB Table: Plural (campaigns)
// Resource: Plural (Campaigns)
// Path: Plural (/campaigns)
// View Template Folder: Plural (/templates/campaigns/)

// CampaignsResource is the resource for the Campaign model
type CampaignsResource struct {
	buffalo.Resource
}

// List gets all Campaigns. This function is mapped to the path
// GET /campaigns
func (v CampaignsResource) List(c buffalo.Context) error {
	claims := c.Value("claims").(jwt.MapClaims)
	user_id, err := uuid.FromString(claims["id"].(string))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad user id"))
	}

	user := &models.User{}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.New("no transaction found")
	}

	// Retrieve all Campaigns from the DB
	if err := tx.Eager("Campaigns").Find(user, user_id); err != nil {
		return c.Error(http.StatusNotFound, errors.New("campaigns not found"))
	}

	return c.Render(http.StatusOK, r.JSON(map[string]models.Campaigns{
		"campaigns": user.Campaigns,
	}))
}

// Show gets the data for one Campaign. This function is mapped to
// the path GET /campaigns/{campaign_id}
func (v CampaignsResource) Show(c buffalo.Context) error {
	claims := c.Value("claims").(jwt.MapClaims)
	user_id, err := uuid.FromString(claims["id"].(string))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad user id"))
	}

	campaign_id, err := uuid.FromString(c.Param("id"))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad campaign id"))
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.New("no transaction found")
	}

	// Allocate an empty Campaign
	campaign := &models.Campaign{}

	// To find the Campaign the parameter campaign_id is used.
	if err := tx.Eager().Where("user_id = ?", user_id).Find(campaign, campaign_id); err != nil {
		return c.Error(http.StatusNotFound, errors.New("campaign not found"))
	}

	return c.Render(200, r.JSON(campaign))
}

// Create adds a Campaign to the DB. This function is mapped to the
// path POST /campaigns
func (v CampaignsResource) Create(c buffalo.Context) error {
	claims := c.Value("claims").(jwt.MapClaims)
	user_id, err := uuid.FromString(claims["id"].(string))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad user id"))
	}

	// Allocate an empty Campaign
	campaign := &models.Campaign{}

	// Bind campaign to the html form elements
	if err := c.Bind(campaign); err != nil {
		return err
	}

	campaign.UserID = user_id

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.New("no transaction found")
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(campaign)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		return c.Error(http.StatusUnprocessableEntity, verrs)
	}

	return c.Render(http.StatusCreated, r.JSON(campaign))
}

// Update changes a Campaign in the DB. This function is mapped to
// the path PUT /campaigns/{campaign_id}
func (v CampaignsResource) Update(c buffalo.Context) error {
	claims := c.Value("claims").(jwt.MapClaims)
	user_id, err := uuid.FromString(claims["id"].(string))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad user id"))
	}

	campaign_id, err := uuid.FromString(c.Param("id"))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad campaign id"))
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.New("no transaction found")
	}

	// Allocate an empty Campaign
	campaign := &models.Campaign{}

	campaign.UserID = user_id

	if err := tx.Where("user_id = ?", user_id).Find(campaign, campaign_id); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	// Bind Campaign to the html form elements
	if err := c.Bind(campaign); err != nil {
		return err
	}

	verrs, err := tx.ValidateAndUpdate(campaign)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		return c.Error(http.StatusUnprocessableEntity, verrs)
	}

	return c.Render(http.StatusOK, r.JSON(campaign))
}

// Destroy deletes a Campaign from the DB. This function is mapped
// to the path DELETE /campaigns/{campaign_id}
// This API should zero out fields associated with the campaign (characters)
// This API should destroy all child elements (quests, maps)
// This API should accept the destroy command, any UI should implement a user check ("Are you sure?")
func (v CampaignsResource) Destroy(c buffalo.Context) error {
	claims := c.Value("claims").(jwt.MapClaims)
	user_id, err := uuid.FromString(claims["id"].(string))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad user id"))
	}

	campaign_id, err := uuid.FromString(c.Param("id"))
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("bad campaign id"))
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.New("no transaction found")
	}

	// Allocate an empty Campaign
	campaign := &models.Campaign{}

	// To find the Campaign the parameter campaign_id is used.
	if err := tx.Where("user_id = ?", user_id).Find(campaign, campaign_id); err != nil {
		return c.Error(http.StatusNotFound, errors.New("campaign not found"))
	}

	characters := models.Characters{}
	if err := tx.Where("campaign_id = ?", campaign.ID).All(&characters); err != nil {
		if errors.Cause(err) != sql.ErrNoRows {
			return c.Error(http.StatusInternalServerError, errors.New("cannot select characters"))
		}
	}
	// zero out campaign ids in attached characters
	for i := range characters {
		characters[i].CampaignID = nulls.UUID{}
	}
	verrs, err := tx.ValidateAndUpdate(characters)
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("could not update characters"))
	}
	if verrs.HasAny() {
		return c.Error(http.StatusUnprocessableEntity, verrs)
	}

	// start to destroy quests
	quests := models.Quests{}
	if err := tx.Where("user_id = ?", user_id).Where("campaign_id = ?", campaign.ID).All(&quests); err != nil {
		if errors.Cause(err) != sql.ErrNoRows {
			return c.Error(http.StatusInternalServerError, errors.New("cannot select quests"))
		}
	}

	for i := range quests {
		// start to destroy maps
		maps := models.Maps{}
		if err := tx.Where("user_id = ?", user_id).Where("quest_id = ?", quests[i].ID).All(&maps); err != nil {
			if errors.Cause(err) != sql.ErrNoRows {
				return c.Error(http.StatusInternalServerError, errors.New("cannot select maps"))
			}
		}

		for i := range maps {
			// start to destroy levels
			levels := models.Levels{}
			if err := tx.Where("user_id = ?", user_id).Where("map_id = ?", maps[i].ID).All(&levels); err != nil {
				if errors.Cause(err) != sql.ErrNoRows {
					return c.Error(http.StatusInternalServerError, errors.New("cannot select levels"))
				}
			}
			if err := tx.Destroy(levels); err != nil {
				return c.Error(http.StatusInternalServerError, errors.New("could not destroy levels"))
			}
			// end to destroy levels
		}

		if err := tx.Destroy(maps); err != nil {
			return c.Error(http.StatusInternalServerError, errors.New("could not destroy maps"))
		}
		// end to destroy maps
	}

	if err := tx.Destroy(quests); err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("could not destroy quests"))
	}
	// end to destroy quests

	// destroy campaign
	if err := tx.Destroy(campaign); err != nil {
		return c.Error(http.StatusInternalServerError, errors.New("could not destroy campaign"))
	}

	return c.Render(http.StatusOK, r.JSON(map[string]string{
		"message": "campaign " + campaign.ID.String() + " deleted",
	}))
}
